#!/usr/bin/env bash

set -euo pipefail

# docker-credential-helper specification implementation using Bitwarden CLI
# Supports: get, store, erase, list

DOCKER_HUB_URL="https://index.docker.io/v1/"
SEARCH_TERM="DockerHub"

# Function to check if bw is installed and unlocked
check_bw() {
    if ! command -v bw &> /dev/null; then
        echo '{"error":"Bitwarden CLI (bw) is not installed"}' >&2
        exit 1
    fi

    # Check if session is unlocked
    if ! bw status | grep -q '"status":"unlocked"'; then
        echo '{"error":"Bitwarden is locked. Please unlock with: export BW_SESSION=$(bw unlock --raw)"}' >&2
        exit 1
    fi
}

# Command: get <server_url>
# Input: server URL from stdin
# Output: {"ServerURL":"...","Username":"...","Secret":"..."}
cmd_get() {
    local server_url
    server_url=$(cat)

    # Only handle Docker Hub
    if [[ "$server_url" != "$DOCKER_HUB_URL" ]]; then
        echo "{\"error\":\"credentials not found for $server_url\"}" >&2
        exit 1
    fi

    check_bw

    # Search for DockerHub credentials
    local items
    items=$(bw list items --search "$SEARCH_TERM" 2>/dev/null)

    if [[ -z "$items" ]] || [[ "$items" == "[]" ]]; then
        echo '{"error":"credentials not found"}' >&2
        exit 1
    fi

    # Parse the first matching item
    local username secret
    username=$(echo "$items" | jq -r '.[0].login.username // empty')
    secret=$(echo "$items" | jq -r '.[0].login.password // empty')

    if [[ -z "$username" ]] || [[ -z "$secret" ]]; then
        echo '{"error":"invalid credentials format"}' >&2
        exit 1
    fi

    # Output in docker-credential-helper format
    jq -n \
        --arg url "$server_url" \
        --arg user "$username" \
        --arg pass "$secret" \
        '{ServerURL: $url, Username: $user, Secret: $pass}'
}

# Command: store
# Input: {"ServerURL":"...","Username":"...","Secret":"..."}
# Output: none (success) or error
# Note: This is a formal implementation. It accepts input but does not update Bitwarden.
cmd_store() {
    local input
    input=$(cat)

    local server_url username secret
    server_url=$(echo "$input" | jq -r '.ServerURL // empty')
    username=$(echo "$input" | jq -r '.Username // empty')
    secret=$(echo "$input" | jq -r '.Secret // empty')

    # Validate input format
    if [[ -z "$server_url" ]] || [[ -z "$username" ]] || [[ -z "$secret" ]]; then
        echo '{"error":"invalid input: ServerURL, Username, and Secret are required"}' >&2
        exit 1
    fi

    # Silently succeed without updating Bitwarden
    exit 0
}

# Command: erase <server_url>
# Input: server URL from stdin
# Output: none (success) or error
# Note: This is a formal implementation. It accepts input but does not update Bitwarden.
cmd_erase() {
    local server_url
    server_url=$(cat)

    # Silently succeed without updating Bitwarden
    exit 0
}

# Command: list
# Output: {"<server_url>":"<username>",...}
cmd_list() {
    check_bw

    # Search for DockerHub credentials
    local items
    items=$(bw list items --search "$SEARCH_TERM" 2>/dev/null)

    if [[ -z "$items" ]] || [[ "$items" == "[]" ]]; then
        echo '{}'
        exit 0
    fi

    # Output map of server URL to username
    local username
    username=$(echo "$items" | jq -r '.[0].login.username // empty')

    if [[ -z "$username" ]]; then
        echo '{}'
    else
        jq -n \
            --arg url "$DOCKER_HUB_URL" \
            --arg user "$username" \
            '{($url): $user}'
    fi
}

# Main dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: $0 <get|store|erase|list>" >&2
        echo "This is a docker-credential-helper for Bitwarden" >&2
        exit 1
    fi

    local command=$1

    case "$command" in
        get)
            cmd_get
            ;;
        store)
            cmd_store
            ;;
        erase)
            cmd_erase
            ;;
        list)
            cmd_list
            ;;
        *)
            echo "Unknown command: $command" >&2
            echo "Supported commands: get, store, erase, list" >&2
            exit 1
            ;;
    esac
}

main "$@"
